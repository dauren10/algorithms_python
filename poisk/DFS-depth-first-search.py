'''
Обход означает посещение всех узлов графа, которое можно выполнить с помощью поиска в глубину или поиска в ширину в python. 
Обход в глубину или поиск в глубину — это алгоритм просмотра всех вершин графа или древовидной структуры данных. 
Здесь мы изучим, что такое поиск в глубину в питоне, разберемся, как он работает с его алгоритмом bfs, реализацией 
с помощью кода на питоне и соответствующим выводом на него.
Что такое поиск в глубину?

Что мы делаем, когда должны решить лабиринт? Мы склонны идти по маршруту, продолжаем идти, пока не обнаружим тупик. 
Дойдя до тупика, мы снова возвращаемся и продолжаем возвращаться, пока не увидим путь, по которому раньше не ходили. 
Возьмите этот новый маршрут. Еще раз идем дальше, пока не обнаружим тупик. Вернитесь снова... Именно так работает поиск в глубину.

Поиск в глубину — это рекурсивный алгоритм, использующий концепцию поиска с возвратом. Он включает в себя тщательный 
поиск всех узлов путем продвижения вперед, если это возможно, а в противном случае - путем возврата. Здесь слово «возврат» означает, 
что когда вы движетесь вперед и на текущем пути больше нет узлов, вы продвигаетесь назад по эквивалентному пути, чтобы найти узлы для прохождения. 
Все узлы продвигаются к посещению на текущем пути до тех пор, пока не будут пройдены все непосещенные узлы, после чего будут выбраны последующие пути.
Алгоритм поиска в глубину

Прежде чем изучать код Python для поиска в глубину и его вывод, давайте рассмотрим алгоритм, которому он следует для того же самого. 
Рекурсивный метод алгоритма поиска в глубину реализован с использованием стека. Стандартная реализация поиска в глубину помещает каждую 
вершину графа в одну из двух категорий: 1) Посещенная 2) Непосещенная. Единственная цель этого алгоритма — посетить все вершины графа, избегая циклов.

Алгоритм DSF выглядит следующим образом:

     Начнем с того, что поместим любую вершину графа на вершину стека.
     После этого берем верхний элемент стека и добавляем его в список посещенных вершин.
     Затем создайте список этого соседнего узла вершины. Добавьте вершины, которых нет в списке посещенных вершин, в верхнюю часть стека.
     Наконец, продолжайте повторять шаги 2 и 3, пока стек не станет пустым.
'''

# Using a Python dictionary to act as an adjacency list
graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}

visited = set() # Set to keep track of visited nodes of graph.

def dfs(visited, graph, node):  #function for dfs 
    if node not in visited:
        print (node)
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)

# Driver Code
print("Following is the Depth-First Search")
dfs(visited, graph, '5')