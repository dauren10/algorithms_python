'''
Поиск в ширину и поиск в глубину в python — это алгоритмы, используемые для обхода графа или дерева. Это две самые важные темы, 
о которых обязательно должен узнать любой начинающий программист на Python. 
Здесь мы изучим, что такое поиск в ширину в питоне, разберемся, как он работает с его алгоритмом, реализацией с помощью кода на 
питоне и соответствующим выводом на него. Кроме того, мы узнаем о применении и использовании поиска в ширину в реальном мире.

 
Что такое поиск в ширину?

Как обсуждалось ранее, поиск в ширину (BFS) — это алгоритм, используемый для обхода графов или деревьев. 
Обход означает посещение каждого узла графа. Поиск в ширину — это рекурсивный алгоритм поиска всех вершин графа или дерева. 
BFS в python можно реализовать с помощью таких структур данных, как словарь и списки. Поиск в ширину в дереве и графе почти одинаков. 
Единственное отличие состоит в том, что граф может содержать циклы, поэтому мы можем снова пройти к тому же узлу.

 
Алгоритм BFS

Прежде чем изучать код Python для Breadth-First и его вывод, давайте рассмотрим алгоритм, которому он следует для того же самого. 
Возьмем, к примеру, кубик Рубика. Кубик Рубика рассматривается как поиск пути, чтобы преобразовать его из полной мешанины цветов в один цвет. 
Таким образом, сравнивая кубик Рубика с графом, мы можем сказать, что возможное состояние кубика соответствует узлам графа, 
а возможные действия кубика соответствуют ребрам графа.

Поскольку поиск в ширину — это процесс обхода каждого узла графа, стандартный алгоритм BFS обходит каждую вершину графа на две части: 1)
 Посещенная 2) Непосещенная. Итак, цель алгоритма — посетить все вершины, избегая циклов.

BFS начинается с узла, затем проверяет все узлы на расстоянии один от начального узла, затем проверяет все узлы на расстоянии два и так далее. 
Чтобы запомнить узлы, которые нужно посетить, BFS использует очередь.
'''

graph = {
  '5' : ['3','7'],
  '3' : ['2', '4'],
  '7' : ['8'],
  '2' : [],
  '4' : ['8'],
  '8' : []
}

visited = [] # List for visited nodes.
queue = []     #Initialize a queue

def bfs(visited, graph, node): #function for BFS
  visited.append(node)
  queue.append(node)

  while queue:          # Creating loop to visit each node
    m = queue.pop(0) 
    print (m, end = " ") 

    for neighbour in graph[m]:
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)

# Driver Code
print("Following is the Breadth-First Search")
bfs(visited, graph, '5')    # function calling